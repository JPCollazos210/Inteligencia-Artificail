<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inteligencia Artificial</title>
</head>

<body>
    <h1>Temas vistos el 15 de agosto clase de inteligencia artificial</h1>
    <h2>- Ciberseguridad</h2>
    <h2>- Computación en la nube</h2>
    <h2>- Inteligencia Artificial</h2>
    <p>En cuanto a la exposición se presentaron multiples casos y eperiencias basadas en el cuidado y seguridad de
        nuestros datos</br>
        nos dieron pautas para mejorar la seguridad de nustros datos, el porque se implementa la computación en la nube
        en las empresas</br>
        y por ultimo el camino de la tecnología y como empezar a implementar la inteligencia artificial</p>

    <h2>Inteligencia Artificial</h2>
    <p>Es aprendimiento y almacenamiento constante con lo cual genera patrones de reconocimiento y busqueda para llevar
        un camino de soluciones </br>
        a una problematica expuesta</p>

    <h1>Temas vistos el 22 de agosto clase de inteligencia artificial</h1>
    <h2>- Algortimo de Búsqueda</h2>
    <p>Se presentaron multiples clases de búqueda para implementar en ciertos tipos de casos, vimos varios terminos</p>
    <p>° Búsqueda</br>
        -Agente</br>
        -Estado</br>
        -Acciones</br>
        -Modelo de transición(Estado-Acción)</br>
        -Espacio de estados</br>
        -Red de nodos dirigidos</br>
        -Prueba de estado</br>
        -Costo de ruta</br>

        ° Problemas de búsqueda</br>
        -Estado inicial</br>
        -acciones</br>
        Modelo de transición</br>
        -Evaluación de meta</br>


        ° Solución</br>
        ° Solución Optima</br>
        ° NODO</br>
        ° Aproximación</br>
        ° Aproximación revisada</br>
        ° Pila LIFO(ultimo sale primero)</br>

        Búsqueda en profundidad (Al nodo más profundo)</br>
        Búsqueda en amplitud(Busca hacia los lados, los más superficiales)</br>
        Cola</br>
        Búsqueda uniformada</p>

    <h1>Colab</h1>
    <a href="https://colab.research.google.com/drive/1xBzGmbkoq6eD4VHrj3Mxrd3oi8xb4NrV?usp=sharing">Practica en
        clase</a>

    <h1>Parcial</h1>
    <h2>Punto 3</h2>
    <table>
        <thead>
            <tr>
                <th>Laberinto</th>
                <th>Algoritmo</th>
                <th>Estados Explorados</th>
                <th>Descripción de la Solución</th>
                <th>Imagen de la Solución</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td rowspan="2">laberinto_vacio</td>
                <td>DFS</td>
                <td>181</td>
                <td>El DFS encontró una solución con un recorrido que explora varios caminos antes de llegar a la meta.
                </td>
                <td><img src="img/Laberinto_vacio1.png" alt="Laberinto Vacio DFS"></td>
            </tr>
            <tr>
                <td>BFS</td>
                <td>1278</td>
                <td>El BFS exploró muchos más estados pero también encontró una solución con un camino más corto y
                    directo.</td>
                <td><img src="img/laberinto_vacio2.png" alt="Laberinto Vacio BFS"></td>
            </tr>
            <tr>
                <td rowspan="2">laberinto_GRUPO_LOS_PRI_PRA</td>
                <td>DFS</td>
                <td>248</td>
                <td>El DFS encontró una solución que atraviesa varias secciones con múltiples desvíos, pero llega a la
                    meta.</td>
                <td><img src="img/laberinto_gupo_PriPra1.png" alt="Laberinto Grupo PriPra DFS"></td>
            </tr>
            <tr>
                <td>BFS</td>
                <td>363</td>
                <td>El BFS encontró un camino más eficiente, con menos desvíos, llegando a la meta con menos
                    exploraciones en total.</td>
                <td><img src="img/laberinto_gupo_PriPra2.png" alt="Laberinto Grupo PriPra BFS"></td>
            </tr>
        </tbody>
    </table>

    <h2>Punto 4</h2>
    <p>
        import tensorflow as tf # Importa la biblioteca TensorFlow, que es una plataforma de código abierto para la
        creación y entrenamiento de modelos de aprendizaje automático y aprendizaje profundo.</br>
        import numpy as np # Importa la biblioteca NumPy, que proporciona soporte para arreglos y matrices
        multidimensionales, así como funciones matemáticas para operar con ellos.</br>
    </p>
    <p>
        celsius = np.array([-40, -10, 0, 8, 15, 22, 38], dtype=float)
        # Crea un arreglo de NumPy llamado 'celsius' que contiene temperaturas en grados Celsius.
        # Los valores se especifican como una lista y se convierten en un arreglo de tipo float (número de punto
        flotante).</br>

        fahrenheit = np.array([-40, 14, 32, 46, 59, 72, 100], dtype=float)
        # Crea un arreglo de NumPy llamado 'fahrenheit' que contiene temperaturas en grados Fahrenheit.
        # Al igual que en el caso anterior, los valores se especifican como una lista y se convierten en un arreglo de
        tipo float.</br>
    </p>
    <p>
        # capa = tf.keras.layers.Dense(units=1, input_shape=[1])</br>
        # Crea una capa densa (fully connected) de TensorFlow con 1 unidad (neurona) y una forma de entrada de 1,
        # que indica que la entrada tendrá una sola característica. Esta línea está comentada y no se ejecuta.</br>

        # modelo = tf.keras.Sequential([capa])</br>
        # Crea un modelo secuencial en TensorFlow que consiste en la capa definida anteriormente.</br>
        # Esta línea también está comentada y no se ejecuta.</br>

        oculta1 = tf.keras.layers.Dense(units=3, input_shape=[1])</br>
        # Crea la primera capa oculta del modelo, que tiene 3 unidades (neuronas) y una forma de entrada de 1,
        # lo que significa que aceptará un único valor de entrada.</br>

        oculta2 = tf.keras.layers.Dense(units=3)</br>
        # Crea la segunda capa oculta del modelo, que también tiene 3 unidades (neuronas).</br>
        # Esta capa no necesita especificar la forma de entrada, ya que TensorFlow puede inferirla automáticamente
        # a partir de la capa anterior.</br>

        salida = tf.keras.layers.Dense(units=1)</br>
        # Crea la capa de salida del modelo, que tiene 1 unidad (neuronas),
        # lo que indica que el modelo producirá un único valor como salida.</br>

        modelo = tf.keras.Sequential([oculta1, oculta2, salida])</br>
        # Crea un modelo secuencial en TensorFlow que consiste en las capas definidas anteriormente:</br>
        # oculta1, oculta2 y salida, formando así una red neuronal simple con dos capas ocultas.</br>

    </p>
    <p>
        modelo.compile(</br>
        # Prepara (compila) el modelo definiendo el optimizador y la función de pérdida que se utilizarán para
        entrenarlo.</br>

        optimizer=tf.keras.optimizers.Adam(0.1),</br>
        # Especifica el optimizador que se usará durante el entrenamiento. En este caso, se usa el optimizador Adam</br>
        # con una tasa de aprendizaje de 0.1. Adam es un optimizador que combina las ventajas de los métodos</br>
        # 'AdaGrad' y 'RMSProp', lo que lo hace eficaz en muchos tipos de problemas de aprendizaje automático.</br>

        loss='mean_squared_error'</br>
        # Especifica la función de pérdida que el modelo debe minimizar durante el entrenamiento.</br>
        # En este caso, se utiliza el 'error cuadrático medio' (mean squared error), que mide la diferencia
        promedio</br>
        # al cuadrado entre los valores predichos por el modelo y los valores reales. Esta función es comúnmente</br>
        # utilizada en problemas de regresión.</br>
        )
    </p>
    <p>
        print("Comenzando entrenamiento...") </br>
        # Imprime un mensaje en la consola indicando que el proceso de entrenamiento del modelo está comenzando.</br>

        historial = modelo.fit(celsius, fahrenheit, epochs=1000, verbose=False) </br>
        # Inicia el proceso de entrenamiento del modelo usando el método 'fit'.</br>
        # - 'celsius' son los datos de entrada (temperaturas en grados Celsius).</br>
        # - 'fahrenheit' son los datos de salida (temperaturas en grados Fahrenheit).</br>
        # - 'epochs=1000' especifica que el modelo será entrenado durante 1000 iteraciones completas sobre el conjunto
        de datos.</br>
        # - 'verbose=False' significa que no se mostrarán mensajes detallados sobre el progreso del entrenamiento.</br>

        print("Modelo entrenado!") </br>
        # Imprime un mensaje en la consola indicando que el modelo ha terminado su proceso de entrenamiento.</br>

    </p>
    <p>
        import matplotlib.pyplot as plt </br>
        # Importa la biblioteca matplotlib.pyplot, que se utiliza para crear visualizaciones y gráficos en Python.</br>

        plt.xlabel("# Epoca") </br>
        # Establece la etiqueta del eje X en el gráfico como "# Epoca", que indica que se mostrarán las épocas
        (iteraciones) del entrenamiento.</br>

        plt.ylabel("Magnitud de pérdida") </br>
        # Establece la etiqueta del eje Y en el gráfico como "Magnitud de pérdida", que indica que se representará la
        magnitud de la pérdida del modelo durante el entrenamiento.</br>

        plt.plot(historial.history["loss"]) </br>
        # Crea un gráfico de líneas que muestra la magnitud de la pérdida (loss) a lo largo de las épocas (epochs).</br>
        # 'historial.history["loss"]' accede a los valores de pérdida almacenados durante el entrenamiento,
        # que se utilizan para visualizar el rendimiento del modelo a lo largo del tiempo.</br>

    </p>
    <p>print("Hagamos una predicción!") </br>
        # Imprime un mensaje en la consola indicando que se va a realizar una predicción con el modelo entrenado.

        resultado = modelo.predict([100.0]) </br>
        # Usa el modelo para hacer una predicción sobre el valor de entrada 100.0 (grados Celsius).</br>
        # 'modelo.predict()' toma un arreglo de entradas y devuelve las predicciones del modelo.</br>
        # En este caso, se pasa un arreglo que contiene un solo valor (100.0).</br>

        print("El resultado es " + str(resultado) + " fahrenheit!") </br>
        # Imprime el resultado de la predicción en la consola. </br>
        # Convierte el resultado (que es un arreglo de NumPy) a una cadena de texto utilizando 'str()'
        # y lo concatena con el mensaje indicando que el resultado está en grados Fahrenheit.</br>
    </p>
    <p>
        print("Variables internas del modelo") </br>
        # Imprime un mensaje en la consola indicando que se van a mostrar las variables internas del modelo,
        # específicamente los pesos de las capas.</br>

        #print(capa.get_weights()) </br>
        # Esta línea está comentada, por lo que no se ejecutará.</br>
        # Si estuviera activa, mostraría los pesos de la capa 'capa', que está definida pero no se usa en el modelo
        actual.</br>

        print(oculta1.get_weights()) </br>
        # Muestra en la consola los pesos y sesgos de la primera capa oculta ('oculta1') del modelo. </br>
        # 'get_weights()' devuelve una lista que contiene dos arreglos: el primer arreglo son los pesos,
        # y el segundo son los sesgos asociados a esa capa.

        print(oculta2.get_weights()) </br>
        # Muestra en la consola los pesos y sesgos de la segunda capa oculta ('oculta2') del modelo. </br>
        # Al igual que antes, 'get_weights()' devuelve una lista con los pesos y sesgos de esta capa.</br>

        print(salida.get_weights()) </br>
        # Muestra en la consola los pesos y sesgos de la capa de salida ('salida') del modelo. </br>
        # Esta línea también utiliza 'get_weights()' para obtener y mostrar la información correspondiente a esta
        capa.</br>

    </p>

    <h2>Punto 4</h2>
    <p>Para poder ejecutarlo recuerda estar en las rutas correctas</p>
    <table>
        <thead>
            <tr>
                <th>Rutas</th>
                
            </tr>
        </thead>
        <tbody>
            <tr>

                <td><img src="img/estructura.png" alt="Laberinto Vacio DFS"></td>
            </tr>
            <tr>

                <td><img src="img/ruta1.png" alt="Laberinto Vacio BFS"></td>
            </tr>
            <tr>

                <td><img src="img/ruta2.png" alt="Laberinto Grupo PriPra DFS"></td>
            </tr>
            <tr>

                <td><img src="img/ruta2_2.png" alt="Laberinto Grupo PriPra BFS"></td>
            </tr>
        </tbody>
    </table>

</body>

</html>